<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatScreen.kt" />
              <option name="originalContent" value="package com.example.chatgptclone&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatScreen(modifier: Modifier) {&#10;    val viewModel: ChatViewModel = hiltViewModel()&#10;    val state = viewModel.state.collectAsState()&#10;    var message by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Collect streamFlow and update UI as soon as chunks arrive&#10;    LaunchedEffect(Unit) {&#10;        viewModel.streamFlow.collect { chunk -&gt;&#10;            // No-op: state is already updated in ViewModel, this triggers recomposition&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        containerColor = Color.DarkGray,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Chat gpt&quot;) }&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding),&#10;            verticalArrangement = Arrangement.Bottom&#10;        ) {&#10;            Box() {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    reverseLayout = true&#10;                ) {&#10;                    items(state.value.asReversed()) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentAlignment = if (it.messageType == &quot;user&quot;) {&#10;                                Alignment.CenterEnd&#10;                            } else {&#10;                                Alignment.CenterStart&#10;                            }&#10;                        ) {&#10;                            Card {&#10;                                Text(it.message)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                TextField(&#10;                    value = message,&#10;                    onValueChange = { message = it }&#10;                )&#10;                Button(&#10;                    onClick = {&#10;                        viewModel.createChatCompletion(message)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Send&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.chatgptclone&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatScreen(modifier: Modifier) {&#10;    val viewModel: ChatViewModel = hiltViewModel()&#10;    val state = viewModel.state.collectAsState()&#10;    var message by remember { mutableStateOf(&quot;&quot;) }&#10;    val streamingAssistantMessage by viewModel.streamingAssistantMessage.collectAsState()&#10;&#10;    // Collect streamFlow and update UI as soon as chunks arrive&#10;    LaunchedEffect(Unit) {&#10;        viewModel.streamFlow.collect { chunk -&gt;&#10;            // No-op: state is already updated in ViewModel, this triggers recomposition&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        containerColor = Color.DarkGray,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Chat gpt&quot;) }&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding),&#10;            verticalArrangement = Arrangement.Bottom&#10;        ) {&#10;            Box() {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    reverseLayout = true&#10;                ) {&#10;                    val chatItems = state.value.asReversed().toMutableList()&#10;                    if (!streamingAssistantMessage.isNullOrEmpty()) {&#10;                        chatItems.add(0, Chat(streamingAssistantMessage!!, &quot;assistant&quot;))&#10;                    }&#10;                    items(chatItems) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentAlignment = if (it.messageType == &quot;user&quot;) {&#10;                                Alignment.CenterEnd&#10;                            } else {&#10;                                Alignment.CenterStart&#10;                            }&#10;                        ) {&#10;                            Card {&#10;                                Text(it.message)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                TextField(&#10;                    value = message,&#10;                    onValueChange = { message = it }&#10;                )&#10;                Button(&#10;                    onClick = {&#10;                        viewModel.createChatCompletion(message)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Send&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatViewModel.kt" />
              <option name="originalContent" value="package com.example.chatgptclone&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.chatgptclone.repo.ChatRepo&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChatViewModel @Inject constructor(private val chatRepo: ChatRepo) : ViewModel() {&#10;&#10;&#10;    private var chatList = mutableListOf&lt;Chat&gt;()&#10;&#10;    var state = MutableStateFlow&lt;List&lt;Chat&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var streamJob: Job? = null&#10;&#10;    val streamFlow = MutableSharedFlow&lt;String&gt;()&#10;&#10;    // Streaming assistant message&#10;    private val _streamingAssistantMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val streamingAssistantMessage = _streamingAssistantMessage.asStateFlow()&#10;&#10;    fun createChatCompletion(message: String) {&#10;        Log.d(&quot;ChatVM&quot;, &quot;createChatCompletion called with message: $message&quot;)&#10;&#10;        chatList.add(&#10;            Chat(&#10;                message = message,&#10;                messageType = &quot;user&quot;&#10;            )&#10;        )&#10;        state.value = chatList.toList()&#10;        Log.d(&quot;ChatVM&quot;, &quot;User message added to chatList and state updated&quot;)&#10;&#10;        // Cancel previous stream if running&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;Previous streamJob cancelled (if any)&quot;)&#10;&#10;        // Build full message history for context&#10;        val messageHistory = mutableListOf&lt;Pair&lt;String, String&gt;&gt;()&#10;        // Add system prompt as the first message&#10;        messageHistory.add(Pair(&quot;system&quot;, &quot;Your name is Ryu, an expert and a genius of Mathematics&quot;))&#10;        // Add all previous chats&#10;        chatList.forEach {&#10;            messageHistory.add(Pair(it.messageType, it.message))&#10;        }&#10;&#10;        streamJob = viewModelScope.launch {&#10;            var assistantMessage = &quot;&quot;&#10;            _streamingAssistantMessage.value = &quot;&quot;&#10;&#10;            Log.d(&quot;ChatVM&quot;, &quot;Starting new stream from repo&quot;)&#10;            chatRepo.streamChatCompletionWithHistory(messageHistory).collect { chunk -&gt;&#10;                Log.d(&quot;ChatVM&quot;, &quot;Received chunk: $chunk&quot;)&#10;&#10;                if (!chunk.startsWith(&quot;[error]:&quot;)) {&#10;                    assistantMessage += chunk&#10;                    streamFlow.emit(chunk)&#10;                    _streamingAssistantMessage.value = assistantMessage&#10;                    Log.d(&quot;ChatVM&quot;, &quot;Emitting chunk to streamFlow&quot;)&#10;&#10;                    // Update last assistant message or add a new one&#10;                    if (chatList.lastOrNull()?.messageType == &quot;assistant&quot;) {&#10;                        chatList[chatList.lastIndex] = chatList.last().copy(message = assistantMessage)&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Updated existing assistant message&quot;)&#10;                    } else {&#10;                        chatList.add(Chat(message = assistantMessage, messageType = &quot;assistant&quot;))&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Added new assistant message&quot;)&#10;                    }&#10;                    state.value = chatList.toList()&#10;                    Log.d(&quot;ChatVM&quot;, &quot;State updated with assistant message&quot;)&#10;                } else {&#10;                    // Handle error case&#10;                    chatList.add(Chat(message = chunk, messageType = &quot;assistant&quot;))&#10;                    state.value = chatList.toList()&#10;                    _streamingAssistantMessage.value = null&#10;                    Log.e(&quot;ChatVM&quot;, &quot;Error received from stream: $chunk&quot;)&#10;                }&#10;            }&#10;            // After streaming is done, add the full assistant message to the chat list&#10;            if (assistantMessage.isNotEmpty()) {&#10;                if (chatList.lastOrNull()?.messageType == &quot;assistant&quot;) {&#10;                    chatList[chatList.lastIndex] = chatList.last().copy(message = assistantMessage)&#10;                } else {&#10;                    chatList.add(Chat(message = assistantMessage, messageType = &quot;assistant&quot;))&#10;                }&#10;                state.value = chatList.toList()&#10;            }&#10;            _streamingAssistantMessage.value = null&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;ViewModel cleared and streamJob cancelled&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.chatgptclone&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.chatgptclone.repo.ChatRepo&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChatViewModel @Inject constructor(private val chatRepo: ChatRepo) : ViewModel() {&#10;&#10;&#10;    private var chatList = mutableListOf&lt;Chat&gt;()&#10;&#10;    var state = MutableStateFlow&lt;List&lt;Chat&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var streamJob: Job? = null&#10;&#10;    val streamFlow = MutableSharedFlow&lt;String&gt;()&#10;&#10;    // Streaming assistant message&#10;    private val _streamingAssistantMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val streamingAssistantMessage = _streamingAssistantMessage.asStateFlow()&#10;&#10;    fun createChatCompletion(message: String) {&#10;        Log.d(&quot;ChatVM&quot;, &quot;createChatCompletion called with message: $message&quot;)&#10;&#10;        chatList.add(&#10;            Chat(&#10;                message = message,&#10;                messageType = &quot;user&quot;&#10;            )&#10;        )&#10;        state.value = chatList.toList()&#10;        Log.d(&quot;ChatVM&quot;, &quot;User message added to chatList and state updated&quot;)&#10;&#10;        // Cancel previous stream if running&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;Previous streamJob cancelled (if any)&quot;)&#10;&#10;        // Build full message history for context&#10;        val messageHistory = mutableListOf&lt;Pair&lt;String, String&gt;&gt;()&#10;        // Add system prompt as the first message&#10;        messageHistory.add(Pair(&quot;system&quot;, &quot;Your name is Ryu, an expert and a genius of Mathematics&quot;))&#10;        // Add all previous chats&#10;        chatList.forEach {&#10;            messageHistory.add(Pair(it.messageType, it.message))&#10;        }&#10;&#10;        streamJob = viewModelScope.launch {&#10;            var assistantMessage = &quot;&quot;&#10;            _streamingAssistantMessage.value = &quot;&quot;&#10;&#10;            Log.d(&quot;ChatVM&quot;, &quot;Starting new stream from repo&quot;)&#10;            chatRepo.streamChatCompletionWithHistory(messageHistory).collect { chunk -&gt;&#10;                Log.d(&quot;ChatVM&quot;, &quot;Received chunk: $chunk&quot;)&#10;&#10;                if (!chunk.startsWith(&quot;[error]:&quot;)) {&#10;                    assistantMessage += chunk&#10;                    streamFlow.emit(chunk)&#10;                    _streamingAssistantMessage.value = assistantMessage&#10;                    Log.d(&quot;ChatVM&quot;, &quot;Emitting chunk to streamFlow&quot;)&#10;&#10;                    // Update last assistant message or add a new one&#10;                    if (chatList.lastOrNull()?.messageType == &quot;assistant&quot;) {&#10;                        chatList[chatList.lastIndex] = chatList.last().copy(message = assistantMessage)&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Updated existing assistant message&quot;)&#10;                    } else {&#10;                        chatList.add(Chat(message = assistantMessage, messageType = &quot;assistant&quot;))&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Added new assistant message&quot;)&#10;                    }&#10;                    state.value = chatList.toList()&#10;                    Log.d(&quot;ChatVM&quot;, &quot;State updated with assistant message&quot;)&#10;                } else {&#10;                    // Handle error case&#10;                    chatList.add(Chat(message = chunk, messageType = &quot;assistant&quot;))&#10;                    state.value = chatList.toList()&#10;                    _streamingAssistantMessage.value = null&#10;                    Log.e(&quot;ChatVM&quot;, &quot;Error received from stream: $chunk&quot;)&#10;                }&#10;            }&#10;            // After streaming is done, add the full assistant message to the chat list&#10;            if (assistantMessage.isNotEmpty()) {&#10;                if (chatList.lastOrNull()?.messageType == &quot;assistant&quot;) {&#10;                    chatList[chatList.lastIndex] = chatList.last().copy(message = assistantMessage)&#10;                } else {&#10;                    chatList.add(Chat(message = assistantMessage, messageType = &quot;assistant&quot;))&#10;                }&#10;                state.value = chatList.toList()&#10;            }&#10;            _streamingAssistantMessage.value = null&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;ViewModel cleared and streamJob cancelled&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/repo/ChatRepo.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/repo/ChatRepo.kt" />
              <option name="originalContent" value="package com.example.chatgptclone.repo&#10;&#10;import android.util.Log&#10;import com.example.chatgptclone.API_KEY&#10;import com.example.chatgptclone.BASE_URL&#10;import com.example.chatgptclone.CHAT_GPT_MODEL&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import okhttp3.Call&#10;import okhttp3.Callback&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import okhttp3.Response&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import java.io.IOException&#10;import javax.inject.Inject&#10;&#10;class ChatRepo @Inject constructor(private val okHttpClient: OkHttpClient){&#10;&#10;    fun streamChatCompletion(message: String): Flow&lt;String&gt; = callbackFlow {&#10;        val url = &quot;${BASE_URL}chat/completions&quot;&#10;        val json = JSONObject().apply {&#10;            put(&quot;model&quot;, CHAT_GPT_MODEL)&#10;            put(&quot;stream&quot;, true)&#10;            put(&quot;messages&quot;, JSONArray().apply {&#10;                put(JSONObject().apply {&#10;                    put(&quot;role&quot;, &quot;system&quot;)&#10;                    put(&quot;content&quot;, &quot;Your name is Ryu, an expert and a genius of Mathematics&quot;)&#10;                })&#10;                put(JSONObject().apply {&#10;                    put(&quot;role&quot;, &quot;user&quot;)&#10;                    put(&quot;content&quot;, message)&#10;                })&#10;            })&#10;        }&#10;        val body = json.toString().toRequestBody(&quot;application/json&quot;.toMediaType())&#10;        val request = Request.Builder()&#10;            .url(url)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $API_KEY&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .post(body)&#10;            .build()&#10;&#10;        val call = okHttpClient.newCall(request)&#10;        call.enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                Log.e(&quot;ChatRepo&quot;, &quot;onFailure: ${e.message}&quot;)&#10;                trySend(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;                close(e)&#10;            }&#10;            override fun onResponse(call: Call, response: Response) {&#10;                Log.d(&quot;ChatRepo&quot;, &quot;onResponse: HTTP ${response.code}&quot;)&#10;                if (!response.isSuccessful) {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;HTTP error: ${response.code} - ${response.message}&quot;)&#10;                    trySend(&quot;[error]: HTTP ${response.code} - ${response.message}&quot;)&#10;                    close(IOException(&quot;HTTP error: ${response.code} - ${response.message}&quot;))&#10;                    return&#10;                }&#10;                val source = response.body?.source() ?: run {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;Null response body&quot;)&#10;                    trySend(&quot;[error]: Null response body&quot;)&#10;                    close(IOException(&quot;Null response body&quot;))&#10;                    return&#10;                }&#10;                try {&#10;                    while (!source.exhausted()) {&#10;                        val line = source.readUtf8Line()&#10;                        Log.d(&quot;ChatRepo&quot;, &quot;Read line: $line&quot;)&#10;                        if (line != null &amp;&amp; line.startsWith(&quot;data: &quot;)) {&#10;                            val data = line.removePrefix(&quot;data: &quot;).trim()&#10;                            Log.d(&quot;ChatRepo&quot;, &quot;Data chunk: $data&quot;)&#10;                            if (data == &quot;[DONE]&quot;) break&#10;                            try {&#10;                                val obj = JSONObject(data)&#10;                                val content = obj&#10;                                    .optJSONArray(&quot;choices&quot;)&#10;                                    ?.optJSONObject(0)&#10;                                    ?.optJSONObject(&quot;delta&quot;)&#10;                                    ?.optString(&quot;content&quot;)&#10;                                Log.d(&quot;ChatRepo&quot;, &quot;Parsed content: $content&quot;)&#10;                                if (!content.isNullOrEmpty()) {&#10;                                    trySend(content)&#10;                                    Log.d(&quot;ChatRepo&quot;, &quot;Sent chunk: $content&quot;)&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;ChatRepo&quot;, &quot;Malformed line: $data, error: ${e.message}&quot;)&#10;                                trySend(&quot;[error]: Malformed line: $data, error: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;Exception: ${e.message}&quot;)&#10;                    trySend(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;                } finally {&#10;                    response.close()&#10;                    close()&#10;                }&#10;            }&#10;        })&#10;        awaitClose { call.cancel() }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.chatgptclone.repo&#10;&#10;import android.util.Log&#10;import com.example.chatgptclone.API_KEY&#10;import com.example.chatgptclone.BASE_URL&#10;import com.example.chatgptclone.CHAT_GPT_MODEL&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import okhttp3.Call&#10;import okhttp3.Callback&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import okhttp3.Response&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import java.io.IOException&#10;import javax.inject.Inject&#10;&#10;class ChatRepo @Inject constructor(private val okHttpClient: OkHttpClient){&#10;&#10;    fun streamChatCompletion(message: String): Flow&lt;String&gt; = callbackFlow {&#10;        val url = &quot;${BASE_URL}chat/completions&quot;&#10;        val json = JSONObject().apply {&#10;            put(&quot;model&quot;, CHAT_GPT_MODEL)&#10;            put(&quot;stream&quot;, true)&#10;            put(&quot;messages&quot;, JSONArray().apply {&#10;                put(JSONObject().apply {&#10;                    put(&quot;role&quot;, &quot;system&quot;)&#10;                    put(&quot;content&quot;, &quot;Your name is Ryu, an expert and a genius of Mathematics&quot;)&#10;                })&#10;                put(JSONObject().apply {&#10;                    put(&quot;role&quot;, &quot;user&quot;)&#10;                    put(&quot;content&quot;, message)&#10;                })&#10;            })&#10;        }&#10;        val body = json.toString().toRequestBody(&quot;application/json&quot;.toMediaType())&#10;        val request = Request.Builder()&#10;            .url(url)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $API_KEY&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .post(body)&#10;            .build()&#10;&#10;        val call = okHttpClient.newCall(request)&#10;        call.enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                Log.e(&quot;ChatRepo&quot;, &quot;onFailure: ${e.message}&quot;)&#10;                trySend(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;                close(e)&#10;            }&#10;            override fun onResponse(call: Call, response: Response) {&#10;                Log.d(&quot;ChatRepo&quot;, &quot;onResponse: HTTP ${response.code}&quot;)&#10;                if (!response.isSuccessful) {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;HTTP error: ${response.code} - ${response.message}&quot;)&#10;                    trySend(&quot;[error]: HTTP ${response.code} - ${response.message}&quot;)&#10;                    close(IOException(&quot;HTTP error: ${response.code} - ${response.message}&quot;))&#10;                    return&#10;                }&#10;                val source = response.body?.source() ?: run {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;Null response body&quot;)&#10;                    trySend(&quot;[error]: Null response body&quot;)&#10;                    close(IOException(&quot;Null response body&quot;))&#10;                    return&#10;                }&#10;                try {&#10;                    while (!source.exhausted()) {&#10;                        val line = source.readUtf8Line()&#10;                        Log.d(&quot;ChatRepo&quot;, &quot;Read line: $line&quot;)&#10;                        if (line != null &amp;&amp; line.startsWith(&quot;data: &quot;)) {&#10;                            val data = line.removePrefix(&quot;data: &quot;).trim()&#10;                            Log.d(&quot;ChatRepo&quot;, &quot;Data chunk: $data&quot;)&#10;                            if (data == &quot;[DONE]&quot;) break&#10;                            try {&#10;                                val obj = JSONObject(data)&#10;                                val content = obj&#10;                                    .optJSONArray(&quot;choices&quot;)&#10;                                    ?.optJSONObject(0)&#10;                                    ?.optJSONObject(&quot;delta&quot;)&#10;                                    ?.optString(&quot;content&quot;)&#10;                                Log.d(&quot;ChatRepo&quot;, &quot;Parsed content: $content&quot;)&#10;                                if (!content.isNullOrEmpty()) {&#10;                                    trySend(content)&#10;                                    Log.d(&quot;ChatRepo&quot;, &quot;Sent chunk: $content&quot;)&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;ChatRepo&quot;, &quot;Malformed line: $data, error: ${e.message}&quot;)&#10;                                trySend(&quot;[error]: Malformed line: $data, error: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;Exception: ${e.message}&quot;)&#10;                    trySend(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;                } finally {&#10;                    response.close()&#10;                    close()&#10;                }&#10;            }&#10;        })&#10;        awaitClose { call.cancel() }&#10;    }&#10;&#10;    fun streamChatCompletionWithHistory(messageHistory: List&lt;Pair&lt;String, String&gt;&gt;): Flow&lt;String&gt; = callbackFlow {&#10;        val url = &quot;${BASE_URL}chat/completions&quot;&#10;        val json = JSONObject().apply {&#10;            put(&quot;model&quot;, CHAT_GPT_MODEL)&#10;            put(&quot;stream&quot;, true)&#10;            put(&quot;messages&quot;, JSONArray().apply {&#10;                messageHistory.forEach { (role, content) -&gt;&#10;                    put(JSONObject().apply {&#10;                        put(&quot;role&quot;, role)&#10;                        put(&quot;content&quot;, content)&#10;                    })&#10;                }&#10;            })&#10;        }&#10;        val body = json.toString().toRequestBody(&quot;application/json&quot;.toMediaType())&#10;        val request = Request.Builder()&#10;            .url(url)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $API_KEY&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .post(body)&#10;            .build()&#10;&#10;        val call = okHttpClient.newCall(request)&#10;        call.enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                Log.e(&quot;ChatRepo&quot;, &quot;onFailure: ${e.message}&quot;)&#10;                trySend(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;                close(e)&#10;            }&#10;            override fun onResponse(call: Call, response: Response) {&#10;                Log.d(&quot;ChatRepo&quot;, &quot;onResponse: HTTP ${response.code}&quot;)&#10;                if (!response.isSuccessful) {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;HTTP error: ${response.code} - ${response.message}&quot;)&#10;                    trySend(&quot;[error]: HTTP ${response.code} - ${response.message}&quot;)&#10;                    close(IOException(&quot;HTTP error: ${response.code} - ${response.message}&quot;))&#10;                    return&#10;                }&#10;                val source = response.body?.source() ?: run {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;Null response body&quot;)&#10;                    trySend(&quot;[error]: Null response body&quot;)&#10;                    close(IOException(&quot;Null response body&quot;))&#10;                    return&#10;                }&#10;                try {&#10;                    while (!source.exhausted()) {&#10;                        val line = source.readUtf8Line()&#10;                        Log.d(&quot;ChatRepo&quot;, &quot;Read line: $line&quot;)&#10;                        if (line != null &amp;&amp; line.startsWith(&quot;data: &quot;)) {&#10;                            val data = line.removePrefix(&quot;data: &quot;).trim()&#10;                            Log.d(&quot;ChatRepo&quot;, &quot;Data chunk: $data&quot;)&#10;                            if (data == &quot;[DONE]&quot;) break&#10;                            try {&#10;                                val obj = JSONObject(data)&#10;                                val content = obj&#10;                                    .optJSONArray(&quot;choices&quot;)&#10;                                    ?.optJSONObject(0)&#10;                                    ?.optJSONObject(&quot;delta&quot;)&#10;                                    ?.optString(&quot;content&quot;)&#10;                                Log.d(&quot;ChatRepo&quot;, &quot;Parsed content: $content&quot;)&#10;                                if (!content.isNullOrEmpty()) {&#10;                                    trySend(content)&#10;                                    Log.d(&quot;ChatRepo&quot;, &quot;Sent chunk: $content&quot;)&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;ChatRepo&quot;, &quot;Malformed line: $data, error: ${e.message}&quot;)&#10;                                trySend(&quot;[error]: Malformed line: $data, error: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;ChatRepo&quot;, &quot;Exception: ${e.message}&quot;)&#10;                    trySend(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;                } finally {&#10;                    response.close()&#10;                    close()&#10;                }&#10;            }&#10;        })&#10;        awaitClose { call.cancel() }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>