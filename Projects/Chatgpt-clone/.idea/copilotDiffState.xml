<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;com.google.devtools.ksp&quot;)&#10;    id(&quot;com.google.dagger.hilt.android&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.chatgptclone&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.chatgptclone&quot;&#10;        minSdk = 27&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(&quot;androidx.room:room-runtime:2.7.2&quot;)&#10;    ksp(&quot;androidx.room:room-compiler:2.7.2&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.7.2&quot;)&#10;&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;&#10;&#10;    implementation(&quot;com.google.dagger:hilt-android:2.56.2&quot;)&#10;    ksp(&quot;com.google.dagger:hilt-android-compiler:2.56.2&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.2.0&quot;)&#10;    ksp(&quot;androidx.hilt:hilt-compiler:1.2.0&quot;)&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;com.google.devtools.ksp&quot;)&#10;    id(&quot;com.google.dagger.hilt.android&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.chatgptclone&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.chatgptclone&quot;&#10;        minSdk = 27&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(&quot;androidx.room:room-runtime:2.7.2&quot;)&#10;    ksp(&quot;androidx.room:room-compiler:2.7.2&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.7.2&quot;)&#10;&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;&#10;&#10;    implementation(&quot;com.google.dagger:hilt-android:2.56.2&quot;)&#10;    ksp(&quot;com.google.dagger:hilt-android-compiler:2.56.2&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.2.0&quot;)&#10;    ksp(&quot;androidx.hilt:hilt-compiler:1.2.0&quot;)&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatScreen.kt" />
              <option name="originalContent" value="package com.example.chatgptclone&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatScreen(modifier: Modifier) {&#10;    val viewModel: ChatViewModel = hiltViewModel()&#10;    val state = viewModel.state.collectAsState()&#10;    var message by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Collect streamFlow and update UI as soon as chunks arrive&#10;    LaunchedEffect(Unit) {&#10;        viewModel.streamFlow.collect { chunk -&gt;&#10;            // No-op: state is already updated in ViewModel, this triggers recomposition&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        containerColor = Color.DarkGray,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Chat gpt&quot;) }&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding),&#10;            verticalArrangement = Arrangement.Bottom&#10;        ) {&#10;            Box() {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    reverseLayout = true&#10;                ) {&#10;                    items(state.value.asReversed()) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentAlignment = if (it.messageType == &quot;user&quot;) {&#10;                                Alignment.CenterEnd&#10;                            } else {&#10;                                Alignment.CenterStart&#10;                            }&#10;                        ) {&#10;                            Card {&#10;                                Text(it.message)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                TextField(&#10;                    value = message,&#10;                    onValueChange = { message = it }&#10;                )&#10;                Button(&#10;                    onClick = {&#10;                        viewModel.createChatCompletion(message)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Send&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.chatgptclone&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatScreen(modifier: Modifier) {&#10;    val viewModel: ChatViewModel = hiltViewModel()&#10;    val state = viewModel.state.collectAsState()&#10;    var message by remember { mutableStateOf(&quot;&quot;) }&#10;    val streamingAssistantMessage by viewModel.streamingAssistantMessage.collectAsState()&#10;&#10;    // Collect streamFlow and update UI as soon as chunks arrive&#10;    LaunchedEffect(Unit) {&#10;        viewModel.streamFlow.collect { chunk -&gt;&#10;            // No-op: state is already updated in ViewModel, this triggers recomposition&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        containerColor = Color.DarkGray,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Chat gpt&quot;) }&#10;            )&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding),&#10;            verticalArrangement = Arrangement.Bottom&#10;        ) {&#10;            Box() {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    reverseLayout = true&#10;                ) {&#10;                    val chatItems = state.value.asReversed().toMutableList()&#10;                    if (!streamingAssistantMessage.isNullOrEmpty()) {&#10;                        chatItems.add(0, Chat(streamingAssistantMessage!!, &quot;assistant&quot;))&#10;                    }&#10;                    items(chatItems) {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentAlignment = if (it.messageType == &quot;user&quot;) {&#10;                                Alignment.CenterEnd&#10;                            } else {&#10;                                Alignment.CenterStart&#10;                            }&#10;                        ) {&#10;                            Card {&#10;                                Text(it.message)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                TextField(&#10;                    value = message,&#10;                    onValueChange = { message = it }&#10;                )&#10;                Button(&#10;                    onClick = {&#10;                        viewModel.createChatCompletion(message)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Send&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/ChatViewModel.kt" />
              <option name="originalContent" value="package com.example.chatgptclone&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.chatgptclone.repo.ChatRepo&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChatViewModel @Inject constructor(private val chatRepo: ChatRepo) : ViewModel() {&#10;&#10;&#10;    private var chatList = mutableListOf&lt;Chat&gt;()&#10;&#10;    var state = MutableStateFlow&lt;List&lt;Chat&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var streamJob: Job? = null&#10;&#10;    val streamFlow = MutableSharedFlow&lt;String&gt;()&#10;&#10;    fun createChatCompletion(message: String) {&#10;        Log.d(&quot;ChatVM&quot;, &quot;createChatCompletion called with message: $message&quot;)&#10;&#10;        chatList.add(&#10;            Chat(&#10;                message = message,&#10;                messageType = &quot;user&quot;&#10;            )&#10;        )&#10;        state.value = chatList.toList()&#10;        Log.d(&quot;ChatVM&quot;, &quot;User message added to chatList and state updated&quot;)&#10;&#10;        // Cancel previous stream if running&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;Previous streamJob cancelled (if any)&quot;)&#10;&#10;        streamJob = viewModelScope.launch {&#10;            var assistantMessage = &quot;&quot;&#10;&#10;            Log.d(&quot;ChatVM&quot;, &quot;Starting new stream from repo&quot;)&#10;            chatRepo.streamChatCompletion(message).collect { chunk -&gt;&#10;                Log.d(&quot;ChatVM&quot;, &quot;Received chunk: $chunk&quot;)&#10;&#10;                if (!chunk.startsWith(&quot;[error]:&quot;)) {&#10;                    assistantMessage += chunk&#10;                    streamFlow.emit(chunk)&#10;                    Log.d(&quot;ChatVM&quot;, &quot;Emitting chunk to streamFlow&quot;)&#10;&#10;                    // Update last assistant message or add a new one&#10;                    if (chatList.lastOrNull()?.messageType == &quot;assistant&quot;) {&#10;                        chatList[chatList.lastIndex] = chatList.last().copy(message = assistantMessage)&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Updated existing assistant message&quot;)&#10;                    } else {&#10;                        chatList.add(Chat(message = assistantMessage, messageType = &quot;assistant&quot;))&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Added new assistant message&quot;)&#10;                    }&#10;                    state.value = chatList.toList()&#10;                    Log.d(&quot;ChatVM&quot;, &quot;State updated with assistant message&quot;)&#10;                } else {&#10;                    // Handle error case&#10;                    chatList.add(Chat(message = chunk, messageType = &quot;assistant&quot;))&#10;                    state.value = chatList.toList()&#10;                    Log.e(&quot;ChatVM&quot;, &quot;Error received from stream: $chunk&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;ViewModel cleared and streamJob cancelled&quot;)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.chatgptclone&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.chatgptclone.repo.ChatRepo&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChatViewModel @Inject constructor(private val chatRepo: ChatRepo) : ViewModel() {&#10;&#10;&#10;    private var chatList = mutableListOf&lt;Chat&gt;()&#10;&#10;    var state = MutableStateFlow&lt;List&lt;Chat&gt;&gt;(emptyList())&#10;        private set&#10;&#10;    private var streamJob: Job? = null&#10;&#10;    val streamFlow = MutableSharedFlow&lt;String&gt;()&#10;&#10;    // Streaming assistant message&#10;    private val _streamingAssistantMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val streamingAssistantMessage = _streamingAssistantMessage.asStateFlow()&#10;&#10;    fun createChatCompletion(message: String) {&#10;        Log.d(&quot;ChatVM&quot;, &quot;createChatCompletion called with message: $message&quot;)&#10;&#10;        chatList.add(&#10;            Chat(&#10;                message = message,&#10;                messageType = &quot;user&quot;&#10;            )&#10;        )&#10;        state.value = chatList.toList()&#10;        Log.d(&quot;ChatVM&quot;, &quot;User message added to chatList and state updated&quot;)&#10;&#10;        // Cancel previous stream if running&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;Previous streamJob cancelled (if any)&quot;)&#10;&#10;        streamJob = viewModelScope.launch {&#10;            var assistantMessage = &quot;&quot;&#10;            _streamingAssistantMessage.value = &quot;&quot;&#10;&#10;            Log.d(&quot;ChatVM&quot;, &quot;Starting new stream from repo&quot;)&#10;            chatRepo.streamChatCompletion(message).collect { chunk -&gt;&#10;                Log.d(&quot;ChatVM&quot;, &quot;Received chunk: $chunk&quot;)&#10;&#10;                if (!chunk.startsWith(&quot;[error]:&quot;)) {&#10;                    assistantMessage += chunk&#10;                    streamFlow.emit(chunk)&#10;                    _streamingAssistantMessage.value = assistantMessage&#10;                    Log.d(&quot;ChatVM&quot;, &quot;Emitting chunk to streamFlow&quot;)&#10;&#10;                    // Update last assistant message or add a new one&#10;                    if (chatList.lastOrNull()?.messageType == &quot;assistant&quot;) {&#10;                        chatList[chatList.lastIndex] = chatList.last().copy(message = assistantMessage)&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Updated existing assistant message&quot;)&#10;                    } else {&#10;                        chatList.add(Chat(message = assistantMessage, messageType = &quot;assistant&quot;))&#10;                        Log.d(&quot;ChatVM&quot;, &quot;Added new assistant message&quot;)&#10;                    }&#10;                    state.value = chatList.toList()&#10;                    Log.d(&quot;ChatVM&quot;, &quot;State updated with assistant message&quot;)&#10;                } else {&#10;                    // Handle error case&#10;                    chatList.add(Chat(message = chunk, messageType = &quot;assistant&quot;))&#10;                    state.value = chatList.toList()&#10;                    _streamingAssistantMessage.value = null&#10;                    Log.e(&quot;ChatVM&quot;, &quot;Error received from stream: $chunk&quot;)&#10;                }&#10;            }&#10;            // After streaming is done, add the full assistant message to the chat list&#10;            if (assistantMessage.isNotEmpty()) {&#10;                if (chatList.lastOrNull()?.messageType == &quot;assistant&quot;) {&#10;                    chatList[chatList.lastIndex] = chatList.last().copy(message = assistantMessage)&#10;                } else {&#10;                    chatList.add(Chat(message = assistantMessage, messageType = &quot;assistant&quot;))&#10;                }&#10;                state.value = chatList.toList()&#10;            }&#10;            _streamingAssistantMessage.value = null&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        streamJob?.cancel()&#10;        Log.d(&quot;ChatVM&quot;, &quot;ViewModel cleared and streamJob cancelled&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/repo/ChatRepo.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/chatgptclone/repo/ChatRepo.kt" />
              <option name="originalContent" value="package com.example.chatgptclone.repo&#10;&#10;import android.util.Log&#10;import com.example.chatgptclone.API_KEY&#10;import com.example.chatgptclone.ApiClient&#10;import com.example.chatgptclone.BASE_URL&#10;import com.example.chatgptclone.CHAT_GPT_MODEL&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import java.io.IOException&#10;class ChatRepo {&#10;    private val okHttpClient = OkHttpClient()&#10;&#10;    suspend fun streamChatCompletion(message: String): Flow&lt;String&gt; = flow {&#10;        Log.d(&quot;Chat-Repo&quot;, &quot;Repo fun initiated&quot;)&#10;        withContext(Dispatchers.IO) {&#10;            val url = &quot;${BASE_URL}chat/completions&quot;&#10;            val json = JSONObject().apply {&#10;                put(&quot;model&quot;, CHAT_GPT_MODEL)&#10;                put(&quot;stream&quot;, true)&#10;                put(&quot;messages&quot;, JSONArray().apply {&#10;                    put(JSONObject().apply {&#10;                        put(&quot;role&quot;, &quot;system&quot;)&#10;                        put(&quot;content&quot;, &quot;Your name is Ryu, an expert and a genius of Mathematics&quot;)&#10;                    })&#10;                    put(JSONObject().apply {&#10;                        put(&quot;role&quot;, &quot;user&quot;)&#10;                        put(&quot;content&quot;, message)&#10;                    })&#10;                })&#10;            }&#10;&#10;            val body = json.toString()&#10;                .toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;            val request = Request.Builder()&#10;                .url(url)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $API_KEY&quot;)&#10;                .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .post(body)&#10;                .build()&#10;&#10;            try {&#10;                okHttpClient.newCall(request).execute().use { response -&gt;&#10;                    if (!response.isSuccessful) {&#10;                        emit(&quot;[error]: HTTP ${response.code} - ${response.message}&quot;)&#10;                        return@withContext&#10;                    }&#10;&#10;                    val source = response.body?.source()&#10;                        ?: throw IOException(&quot;Null response body&quot;)&#10;&#10;                    while (!source.exhausted()) {&#10;                        val line = source.readUtf8Line()&#10;                        if (line != null &amp;&amp; line.startsWith(&quot;data: &quot;)) {&#10;                            val data = line.removePrefix(&quot;data: &quot;).trim()&#10;                            if (data == &quot;[DONE]&quot;) break&#10;&#10;                            try {&#10;                                val obj = JSONObject(data)&#10;                                val content = obj&#10;                                    .optJSONArray(&quot;choices&quot;)&#10;                                    ?.optJSONObject(0)&#10;                                    ?.optJSONObject(&quot;delta&quot;)&#10;                                    ?.optString(&quot;content&quot;)&#10;&#10;                                if (!content.isNullOrEmpty()) {&#10;                                    emit(content)&#10;                                }&#10;                            } catch (_: Exception) {&#10;                                // Ignore malformed lines&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                emit(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.chatgptclone.repo&#10;&#10;import android.util.Log&#10;import com.example.chatgptclone.API_KEY&#10;import com.example.chatgptclone.ApiClient&#10;import com.example.chatgptclone.BASE_URL&#10;import com.example.chatgptclone.CHAT_GPT_MODEL&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import org.json.JSONArray&#10;import org.json.JSONObject&#10;import java.io.IOException&#10;class ChatRepo {&#10;    private val okHttpClient = OkHttpClient()&#10;&#10;    suspend fun streamChatCompletion(message: String): Flow&lt;String&gt; = flow {&#10;        Log.d(&quot;Chat-Repo&quot;, &quot;Repo fun initiated&quot;)&#10;        withContext(Dispatchers.IO) {&#10;            val url = &quot;${BASE_URL}chat/completions&quot;&#10;            val json = JSONObject().apply {&#10;                put(&quot;model&quot;, CHAT_GPT_MODEL)&#10;                put(&quot;stream&quot;, true)&#10;                put(&quot;messages&quot;, JSONArray().apply {&#10;                    put(JSONObject().apply {&#10;                        put(&quot;role&quot;, &quot;system&quot;)&#10;                        put(&quot;content&quot;, &quot;Your name is Ryu, an expert and a genius of Mathematics&quot;)&#10;                    })&#10;                    put(JSONObject().apply {&#10;                        put(&quot;role&quot;, &quot;user&quot;)&#10;                        put(&quot;content&quot;, message)&#10;                    })&#10;                })&#10;            }&#10;&#10;            val body = json.toString()&#10;                .toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;            val request = Request.Builder()&#10;                .url(url)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $API_KEY&quot;)&#10;                .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .post(body)&#10;                .build()&#10;&#10;            try {&#10;                okHttpClient.newCall(request).execute().use { response -&gt;&#10;                    Log.d(&quot;Chat-Repo&quot;, &quot;HTTP response received: ${response.code}&quot;)&#10;                    if (!response.isSuccessful) {&#10;                        emit(&quot;[error]: HTTP ${response.code} - ${response.message}&quot;)&#10;                        Log.e(&quot;Chat-Repo&quot;, &quot;HTTP error: ${response.code} - ${response.message}&quot;)&#10;                        return@withContext&#10;                    }&#10;&#10;                    val source = response.body?.source()&#10;                        ?: throw IOException(&quot;Null response body&quot;)&#10;&#10;                    var lineCount = 0&#10;                    while (!source.exhausted()) {&#10;                        val line = source.readUtf8Line()&#10;                        Log.d(&quot;Chat-Repo&quot;, &quot;Read line: $line&quot;)&#10;                        if (line != null &amp;&amp; line.startsWith(&quot;data: &quot;)) {&#10;                            val data = line.removePrefix(&quot;data: &quot;).trim()&#10;                            Log.d(&quot;Chat-Repo&quot;, &quot;Data chunk: $data&quot;)&#10;                            if (data == &quot;[DONE]&quot;) break&#10;&#10;                            try {&#10;                                val obj = JSONObject(data)&#10;                                val content = obj&#10;                                    .optJSONArray(&quot;choices&quot;)&#10;                                    ?.optJSONObject(0)&#10;                                    ?.optJSONObject(&quot;delta&quot;)&#10;                                    ?.optString(&quot;content&quot;)&#10;&#10;                                if (!content.isNullOrEmpty()) {&#10;                                    emit(content)&#10;                                    Log.d(&quot;Chat-Repo&quot;, &quot;Emitted content: $content&quot;)&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;Chat-Repo&quot;, &quot;Malformed line: $data, error: ${e.message}&quot;)&#10;                            }&#10;                        }&#10;                        lineCount++&#10;                    }&#10;                    Log.d(&quot;Chat-Repo&quot;, &quot;Total lines read: $lineCount&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                emit(&quot;[error]: ${e::class.simpleName} - ${e.message ?: &quot;No message&quot;}&quot;)&#10;                Log.e(&quot;Chat-Repo&quot;, &quot;Exception: ${e::class.simpleName} - ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>